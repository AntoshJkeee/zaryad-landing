### Backlog

1. [ ] После появления букв, все последовательно должны гличнуть
2. [ ] Последовательное анимированное появление пунктов меню
3. [ ] Подключить прелоадер-эффект на старте загрузки страницы
4. [ ] По клику на пункт меню, буквы должны уезжать в противоположную сторону
5. [ ] Добавить клич эффект на пунты меню
6. [ ] Сверстать контент внутри менюшек
7. [ ] Наложить эффекты анимаций на контент меню

### Об инструменте

[Minista](https://minista.qranoko.jp/) - это SSG фреймворк, а точнее надстройка над сборщиком проектов [Vite](https://vite.dev/ "документация Vite").
При установке, этот фреймворк автоматически устанавливает в `devDependecies` зависимости `react` и `react-dom`.
Это необходимо для того, чтобы мы могли вести комфортную разработку в компонентном подходе используя `JSX` со всеми его возможностями шаблонизатора.

Minista компилирует `JSX` в чистый `HTML`, поэтому стоит отметить, что манипуляции с кодом внутри `JSX` файлов, например `console.log("Hello")` вы не увидете в браузере. Интуитивно, вы должны представлять ваши компоненты как серверные, подобно тому-же Next.JS, поэтому любые данные вы увидите в своем терминале на уровне сервера.
Фактически же, `minista` работает в связке с методом `React` `renderToStaticMarkup` [можно почитать здесь](https://reactdev.ru/reference/react-dom/server/renderToStaticMarkup/) и `esbuild` бандером.

<hr style="border-top: 1px dashed gray" />

### Команды для работы с проектом

- `npm start` - запуск проекта локально `development` версии.
- `npm run preview` - запуск проекта локально `production` версии.
- `npm run build` - создание билда проекта.
- `npm run lint` - запуск проверки линтов проекта на соответствие правил стилей и скриптов.

<hr style="border-top: 1px dashed gray" />

### Версии core инструментов проекта

- node js — v22.13.1
- react, react-dom — v18.2.0
- sass — 1.81.0
- vite — 4.4.7 (зависимость minista)
test

<hr style="border-top: 1px dashed gray" />

### Папки структуры проекта

- **public** — хранит ресурсы, которые не нужно обрабатывать сборщиком проекта. При билде сборщик будет переносить их финальную папку как есть, без изменений
- **src** — хранит исходные файлы проекта
- **build** — хранит собранную версию проекта
- **node_modules** — хранит npm модули проекта
- **.git-hooks** — хранит `shell` скрипты-хуки для подписки на события git

<hr style="border-top: 1px dashed gray" />

- **src/assets** — хранит ресурсы, которые будут обрабатываться сборщиком проектов. Например картинки будут минифицироваться и оптимизироваться в современные форматы, а svg иконки из этой папки будут собираться в спрайт
- **src/components** — хранит компоненты проекта, которые можно использовать на всех слоях
- **src/utils** — хранит вспомогательные `.ts` функции, которые можно использовать по всему проекту
- **src/layouts**  — хранит компоненты разметки, которые могут использоваться буквально на каждой странице проекта
- **src/store** — хранит данные для страниц проекта
- **src/sections** — хранит секции проекта
- **src/pages** — хранит страницы проекта
- **src/styles** — хранит файлы стилей с глобальными переменными, утилитарными функциями, миксинами, медиавыражения и тд.

<hr style="border-top: 1px dashed gray" />

- **src/utils/constants** — хранит постоянные `.ts` константные сущности для всего проекта
- **src/utils/helpers** — хранит вспомогательные `.ts` функции для всего проекта
- **src/utils/modules** — хранит полноценные `.ts` модули с реализацией какой-либо сущности

<hr style="border-top: 1px dashed gray" />

- **src/assets/css** — хранит кастомные css файлы проекта
- **src/assets/fonts** — хранит шрифты проекта
- **src/assets/images** — хранит изображения проекта

<hr style="border-top: 1px dashed gray" />

- **src/styles/helpers** — ...
- **src/styles/fonts.scss** — хранит подключения шрифтов к проекту

<hr style="border-top: 1px dashed gray" />

- **project-name/** — все остальные файлы, лежащие в корне проекта являются сугубо конифурационными, и требуют вмешательство и изменения
  только в исключительных случаях

<hr style="border-top: 1px dashed gray" />

### Алиасы

`Aliases` — это сокращения для путей. Чтобы не двигаться по иерархии папок через постоянные `../../../`, сборка проекта уже настроена таким образом,
что спецсимвол `@` будет отсчитывать свой путь от корня проекта с исходниками `src/`. Конфигурацию можно найти в файлах `jscofig.json` и `minista.config.ts/resolve/alias`

<hr style="border-top: 1px dashed gray" />

### SCSS Code Style

**Элемент (Element)**\
часть блока, которая не используется в отрыве от него. Обозначается двойным нижним подчеркиванием после имени блока

Примеры: `.header__logo {}`, `.slider-news__element-card {}`.

**Модификатор (Modifier)**\
определяет внешний вид или поведение блока, или элемента. Обозначается одним нижним подчеркиванием после имени блока или элемента

Примеры: `.header_large {}, .slider-news_current {}`

> **Ключевые моменты**
> - Имена классов должны быть понятными и описательными
> - Используйте только латиницу
> - Разделяйте слова дефисами в стиле **kebab-case**
> - Не используйте цифры в начале имени класса
> - Избегайте сокращений, если они не очевидны

<hr style="border-top: 1px dashed gray" />

### Компонентный подход

Компонентный подход - это метод разработки программного обеспечения, при котором система разбивается на независимые модули или компоненты. Каждый компонент выполняет конкретную функцию и может быть легко заменен или модифицирован без влияния на другие части системы. Вся логика, верстка и стили складываются в одну папку компонента, так чтобы они лежали рядом на одном уровне и их нахождении и принадлежность составляло минимальное время.

> **Основные характеристики компонентного подхода:**
> - Модульность: система состоит из отдельных модулей (компонентов).
> - Независимость: компоненты могут быть разработаны и тестированы независимо друг от друга.
> - Переиспользуемость: компоненты могут использоваться в различных частях системы или даже в других проектах.
> - Гибкость: легко добавлять новые функции или модифицировать существующие без значительных изменений в остальной части системы.

<hr style="border-top: 1px dashed gray" />

### Именование сущностей Store

Все сущности в store должны иметь camelCase нотацию 

- `buttonEl` — для компонентов, приписка `El` в конце.
- `cardItems` — для итерабильных сущностей, приписка `Items` в конце.
- `text/titleId/other` — уникальные сущности можно называть по своему усмотрению
- `isActive` — для буллевых флагов и классов, приписка `is` вначале
- `hasPagination` — для буллевых флагов указывающих на наличие, приписка `has` вначале

<hr style="border-top: 1px dashed gray" />

### Git-flow команды

Все проекты должны иметь ветки **main** и **develop**.\
**main** - представление `production` версии. Для готового и проверенного представления фичи.\
**develop** - представление `develop` версии. Для тестирования фичи _(гермиона / тестировщик / менеджер / pixel perfect)_.

1. Всю работу начинаем с ветки **main** с последующим ответвлением от неё. Команда: `git checkout main`.
2. В первую очередь надо проверить актуальность ветки **main** и если есть изменения, то подтянуть из удаленного репозитория. Команда: `git status; git pull`.
3. Когда задача (таска) берется в работу всегда необходимо ответвляться от ветки **main**. Команда: `git checkout -b Task-36991-130-no-scroll`.
4. Под каждую задачу создается отдельная ветка именуемая номером задачи из таски в ActiveCollab и словами описывающими заголовок из таски на английском в `kebab-case`. Пример: **Task-36991-130-no-scroll**. Команда:  `git checkout -b Task-36991-130-no-scroll`.
5. По завершению выполнения задачи отдаем ее на тестирование для этого создаем `merge request` с задачей _Task-36991-130-no-scroll_ в ветку `develop`.
6. После успешного `merge request` и проведенного тестирования фичи на **develop**, ветку фичи _Task-36991-130-no-scroll_ необходимо влить в ветку **main** через `merge request` и провести проверку и тестирование.

> ⚠ СТРОГО ЗАПРЕЩЕНО ВЛИВАТЬ ВЕТКУ **develop** В ВЕТКУ **main**
>
> При возникновении конфликта при `merge request` в ветку **develop** требуется:
> - от фича ветки _Task-36991-130-no-scroll_ создать ветку для решения конфликта _develop-conflict-Task-36991-130-no-scroll_
> - в ветку _develop-conflict-Task-36991-130-no-scroll_ влить актуальную ветку **develop** и решить конфликты
> - при успешном решении конфликтов создать `merge request` в ветку **develop** из ветки _develop-conflict-Task-36991-130-no-scroll_
> - удалить ветку _develop-conflict-Task-36991-130-no-scroll_

> Дополнительные материалы:
>
> 📚 [GitFlow от atlassian](https://www.atlassian.com/ru/git/tutorials/comparing-workflows/gitflow-workflow "статья о Git-flow")\
> 📚 [Зачем нужен Pixel Perfect](https://htmlacademy.ru/blog/css/pixel-perfect "статья о Pixel Perfect")

<hr style="border-top: 1px dashed gray" />

### Плагины  стилей

- `postcss-pxtorem` — проходится по всему css коду и выполняет замену всех единиц измерения `px` на `rem` для `production` сборки с делением коэфицента на 16 (стандартный `font-size` тега `html`)

- `postcss-preset-env` — позволяет преобразовывать современный CSS в конструкции, которые понимает большинство браузеров